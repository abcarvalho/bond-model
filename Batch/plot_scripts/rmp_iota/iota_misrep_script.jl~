

using Interpolations
using Distributed
using DataFrames
using Printf
using JLD
using CSV
using Dierckx
# using Dates
# using PyPlot
# using PyCall
# using Seaborn
# using LaTeXStrings

main_path = "/home/artur/BondPricing"
module_path = string(main_path, "/", "Julia/modules/")
modls = ["ModelObj", "AnalyticFunctions", "BondPrInterp",
         "EqFinDiff", "Batch", "ModelPlots", "JointEq"]
for modl in modls
    include(string(joinpath(module_path, modl), "/", modl, ".jl"))
end

# Set Parameters ##########################################
cvmdict = Dict{Symbol,Array{Float64,1}}(:sigmal => [0.15],
                               :m  => [1.],
                               :gross_delta => [0.02],
                               :kappa  => [25 * 1e-4],
                               :mu_b => [1.0],
                               :xi => [1.0],
                               :iota => [x for x in Batch.cvm_param_values_dict[:iota] 
                                         if x <= 25. * 1e-4])
svmdict = deepcopy(cvmdict)
svmdict[:lambda] = [.2]
# svmdict[:kappa] = [25 * 1e-4]
svmdict[:iota] = [.0]
svmdict[:sigmah] = [.225]
# #########################################################

firm_obj_fun = :firm_value 
cvmdf, svmdf, _ = ModelPlots.get_cvm_svm_dfs(cvmdict, svmdict;
                                             firm_obj_fun=firm_obj_fun)

# Safe Firm
sf_iota = 2.5 * 1e-4
sf_comb_num = cvmdf[abs.(cvmdf[:iota] .- sf_iota) .< 1e-5, :comb_num][1]


LL = [ ]
# for sf_comb_num in cvm_combs[1]

# Preliminary Objects #####################################
sf_bt, sf = Batch.get_bt_mobj(; model="cvm", comb_num=sf_comb_num)
sf = ModelObj.set_opt_k_struct(sf, cvmdf)

# Capital Structure -> Fixed
jks = JointEq.JointKStruct(1., 
                           sf.optKS.mu_b,
                           sf.optKS.m, sf.optKS.c, sf.optKS.p, 
                           NaN, NaN, NaN, NaN, NaN)

# rf_bt, rf = Batch.get_bt_svm(; comb_num=svm_combs[1])
rf_bt, rf = Batch.get_bt_svm(; comb_num=svmdf[1, :comb_num])

# Joint Firm Object
jf = JointEq.JointFirms(jks, sf, rf,
                        sf_bt,
                        rf_bt,  
                        cvmdf, svmdf)    
# #########################################################

for rf_comb_num in svmdf[:comb_num] #svm_combs
    rf_bt, rf = Batch.get_bt_svm(; comb_num=rf_comb_num)
    
    # Joint Firm Object
    jf = JointEq.JointFirms(jks, sf, rf,
                            sf_bt,
                            rf_bt,  
                            cvmdf, svmdf)
    
    # Joint Equilibrium Parameters
    jep = JointEq.store_joint_eq_parameters(jks.mu_s, sf.pm.kappa, sf.pm.kappa;
                                            s_iota=sf.pm.iota,
                                            s_lambda=sf.pm.lambda,
                                            s_sigmah=sf.pm.sigmah,
                                            r_iota=rf.pm.iota,
                                            r_lambda=rf.pm.lambda,
                                            r_sigmah=rf.pm.sigmah)
    
    # Compute Misrepresentation
    jeq = JointEq.ep_constructor(jep, jf.cvm_bt, jf.svm_bt;
                                 ep_jks=jks,
                                 run_pool_eq=false,
                                 run_sep_eq=false,                       
                                 sf_obj_fun=firm_obj_fun,
                                 rf_obj_fun=firm_obj_fun,
                                 rerun_full_info=false,
                                 rerun_misrep=true,
                                 rerun_pool=false,
                                 rerun_sep=false)
    
    
    push!(LL, getfield(jeq, :misrep))
end

return jf, cvmdf, svmdf, LL
# end

# return jf, cvm_combs, svm_combs, LL


